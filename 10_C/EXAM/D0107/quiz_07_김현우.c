/* *******************************************************************
* Quiz 7-1) 64bit OS에서 가능한 메모리 주소의 범위는?
* ********************************************************************/
// 64bit os에서는 주소를 표현하기 위해서 8 bytes(64bit)를 사용
// 즉, 2^64-1 byte 만큼의 메모리를 다룰 수 있다.


/* *******************************************************************
* Quiz 7-2) 출력 결과 예측
* ********************************************************************/
//#include <stdio.h>
// 
//int main(void) {
//	int i = 100;
//	int* ptr = &i;
//	int i2 = *ptr
// 
//	*ptr = 200;
//	printf("i = %d\n", i);			200
//	printf("i2 = %d\n", i2);		100
//	printf("*ptr = %d\n", *ptr);	200
//	printf("&i = %p\n", &i);		i의 주소값
//	printf("ptr = %p\n", ptr);		i의 주소값
// 
//	return 0;
//}


/* *******************************************************************
* Quiz 7-3) 포인터 ptr을 사용해 배열 arr의 모든 요소를 합하고 평균을 출력하는 예제 작성
* ********************************************************************/
//// 헤더 파일
//#include <stdio.h>
//
//// 메인 함수
//int main(void)
//{
//	int arr[] = { 1, 2, 3, 4, 5, 6 };
//	int* ptr = &arr;
//
//	int sum = 0;
//	const int LEN = sizeof(arr) / sizeof(arr[0]);
//
//	for (int i = 0; i < LEN; i++)
//	{
//		sum += *(ptr + i);
//	}
//
//	printf("합   : %d\n", sum);
//	printf("평균 : %.2f", (float)sum / LEN);
//
//	return 0;
//}


/* *******************************************************************
* Quiz 7-4) 에러가 발생하지 않는 것
* ********************************************************************/
// 1. 상수는 ++연산 적용 불가능
// 2. ptr이 다음 위치 arr[1]을 가리키게 만든다, 가능
// 3. 상수에 다른 값을 적용할 수 없음
// 4. *(arr+1) -> arr[i]와 같은 의미, 가능
// 5. 상수는 ++연산 적용 불가능
// 6. (*arr)++ -> arr[0]과 같은 의미 arr[0]의 값을 증가시키는 것, 가능


/* *******************************************************************
* Quiz 7-5) arr이 길이가 4인 int배열일 때, sizeof(arr)과 sizeof(arr+0)의 결과는?
* ********************************************************************/
// - sizeof(arr)	: 16 (4개의 요소마다 4 bytes(int))
// - sizeof(arr+0)	: arr = arr[0], arr+0 -> arr[0]과 같은 의미
//					  즉, 4 bytes					  
